#' Perform Sensitivity Analysis
#'
#' This function performs sensitivity analysis on NAPHSIS data.
#'
#' @param ndraws Number of draws for the simulation.
#' @param as_prob_csv A CSV file containing the estimated probability of
#' arsenic levels.
#' @param birth_data_txt A TXT file containing the birth data.
#' @param output_dir The output directory.
#' @param targets A vector of target variables.
#' @param as_cat_label A vector of arsenic categories generated by the random
#' forest model.
#' @param drop_as_cat_label_reg A vector of arsenic categories to drop from the
#' regression analysis.
#' @param seed The seed for the random number generator.
#' @return A list of data frames with the imputed arsenic levels.
#' @export
perform_sensitivity_analysis <- function(
  ndraws = 10,
  as_prob_csv,
  birth_data_txt,
  output_dir,
  targets = c("OEGEST", "BWT"),
  as_cat_label = c("As<5", "As5-10", "As10+"),
  drop_as_cat_label_reg = c("As<5"),
  seed = 12345
) {
  set.seed(seed) # set seed for reproducibility
  # Create the output directory if it does not exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # Load and process file containing estimated probability of As levels <5,
  # >=5-10, and >10ug/L for each unique raster cell. These data were resampled
  # from 500m^2 raster cells to 1000m^2 to match well density dataset.
  datmatx <- data.table::fread(
    as_prob_csv, header = TRUE,
    showProgress = TRUE,
    nThread = parallel::detectCores()
  )

  # Probabilities for each raster (right now just the raster cells used to fit
  # the model, but will generalize for real code)
  rasterprobmatrix <- cbind(
    datmatx$RFC3_C1v2, datmatx$RFC3_C2v2, datmatx$RFC3_C3v2
  )   # get multinomial probability vector for each raster cell
  cellpop <- datmatx$Wells_2010  # population of well users for each raster
  # cell in 2010; other census years might be preferable!
  # set length to 5 digits (pad w/ leading zeros)
  datmatx$GEOID10 <- sprintf("%05d", datmatx$GEOID10)
  county_id_list <- na.omit(unique(datmatx$GEOID10))
  n_counties <- length(county_id_list)

  # Now, make a storage space for each of the "arsenic-imputed" datasets.
  # You need enough draws that your distribution approximates closely the
  # sampling distribution given by the multinomial probabilities that were
  # given from the random forest USGS model.
  countydf <- data.frame(countyID = county_id_list)
  # Read in data -- 3751755 singleton births in 2016 to US-resident mothers
  # excluding implausible gestational age/birth weights and congenital anomalies
  births <- data.table::fread(birth_data_txt, header = TRUE)

  # Exclude individuals with missing covariate data (n = 3672449 remain)

  columns_to_select <- c(
    "RFCprobC2", "RFCprobC3", "MAGE_R",
    "MRACEHISP", "MRACEHISP_F", "MEDUC_2",
    "MEDUC_3", "MEDUC_4", "smoke", "RUCC",
    "RUCC_F", "pm", "DMAR_1", "FIPS", "MRSTATE",
    "BWT", "OEGEST_R3", "OEGEST"
  )

  births <- births %>%
    dplyr::select(dplyr::all_of(columns_to_select)) %>%
    dplyr::filter(complete.cases(.)) %>%
    dplyr::mutate(rural = .data$RUCC > 3) # generate binary rural/urban variable
  # set length to 5 digits (pad w/ leading zeros)
  births$FIPS <- sprintf("%05d", births$FIPS)
  as_draw_data <- merged_data <- rep(list(countydf), ndraws)

  system.time({
    as_temp <- matrix(NA, n_counties, ndraws)
    ncats <- length(as_cat_label)
    for (i in 1:n_counties) {
      cells_i <- which(datmatx$GEOID10 == county_id_list[i])
      # raster cells in county i
      # direct computation of probability of each As category,
      # randomly sampling both raster cell and As category from a county:
      # this is equivalent (but likely faster) to randomly sampling the raster
      # within a county, then the As category
      prob_values <- apply(
        rasterprobmatrix[cells_i, ],
        2,
        weighted.mean,
        w = cellpop[cells_i],
        na.rm = TRUE
      )
      as_temp[i, ] <- sample(
        1:ncats,
        size = ndraws,
        replace = TRUE,
        prob = prob_values
      )
    }
    for (j in 1:ndraws) {
      as_draw_data[[j]]$AsLevel <- factor(
        as_temp[, j], levels = 1:ncats, labels = as_cat_label
      )
      merged_data[[j]] <- merge(
        births, as_draw_data[[j]], by.x = "FIPS", by.y = "countyID"
      )
    }
  })
  lst_data <- Map(as.data.frame, merged_data)
  births <- data.table::rbindlist(lst_data, idcol = TRUE)
  filtered_as_cat_label <- base::setdiff(as_cat_label, drop_as_cat_label_reg)
  if (length(filtered_as_cat_label) == 0) {
    stop("No arsenic categories to analyze")
  }
  res <- regression_analysis(
    births,
    targets,
    filtered_as_cat_label,
    output_dir
  )
  return(res)
}

#' Perform Regression Analysis
#'
#' This function performs regression analysis on NAPHSIS data.
#'
#' @param births A data frame containing the birth data.
#' @param targets A vector of target variables.
#' @param as_cat_label A vector of arsenic categories generated by the random
#' forest model.
#' @param output_dir The output directory.
#' @return A list of data frames with the regression results.
regression_analysis <- function(
  births,
  targets,
  as_cat_label,
  output_dir
) {
  # Fit a regression model within each of the "simulated arsenic category
  # worlds".
  # Append the results into the results matrices of coefficients and their
  # standard errors (SE).
  # This process involves grouping the data by the simulated arsenic levels
  # and fitting a linear mixed-effects model.
  # The model includes various covariates such as maternal age,
  # race/ethnicity, education, smoking status, and rural/urban status.
  # The random effects structure accounts for the hierarchical nature of the
  # data, with random intercepts for states and counties.

  results <- list()
  for (var in targets) {
    var_adj_overall_rfc_se <- births %>%
      dplyr::group_by(.id) %>%
      dplyr::do(
        fitmodel = lme4::lmer(
          as.formula(paste(
            var, "~ as.factor(AsLevel) +",
            "rms::rcs(MAGE_R, parms = 3) +",
            "as.factor(MRACEHISP_F) +",
            "MEDUC_2 +",
            "MEDUC_3 +",
            "MEDUC_4 +",
            "as.factor(RUCC_F) +",
            "DMAR_1 +",
            "smoke +",
            "pm +",
            "(1 | MRSTATE / FIPS)"
          )),
          data = .
        )
      )

    # Define the terms to filter by
    terms_to_filter <- paste0("as.factor(AsLevel)", as_cat_label)

    # Initialize an empty data frame to store the combined results
    var_combined_results <- data.frame()

    # Loop through each model and filter by terms
    for (i in seq_along(var_adj_overall_rfc_se$fitmodel)) {
      model_results <- broom.mixed::tidy(var_adj_overall_rfc_se$fitmodel[[i]])
      for (filtered_term in terms_to_filter) {
        filtered_results <- model_results %>%
          dplyr::filter(.data$term == filtered_term)
        var_combined_results <- dplyr::bind_rows(
          var_combined_results, filtered_results
        )
      }
    }
    deg_freedom <- as.integer(
      broom.mixed::glance(var_adj_overall_rfc_se$fitmodel[[1]])$df.residual
    )

    var_combined_results_terms <- data.frame()
    for (filtered_term in terms_to_filter) {
      var_combined_results_term <- var_combined_results %>%
        dplyr::filter(.data$term == filtered_term)
      var_combined_results_term <- as.data.frame(
        Amelia::mi.meld(
          q = as.matrix(var_combined_results_term$estimate),
          se = as.matrix(var_combined_results_term$std.error)
        )
      )
      var_combined_results_term <- var_combined_results_term %>%
        dplyr::mutate(
          statistic = .data$q.mi / .data$se.mi,
          conf.low = .data$q.mi + .data$se.mi * qt(0.025, deg_freedom),
          conf.high = .data$q.mi + .data$se.mi * qt(0.975, deg_freedom),
          p.value = 2 * pt(
            abs(.data$statistic), deg_freedom,
            lower.tail = FALSE
          )
        )
      var_combined_results_terms <- dplyr::bind_rows(
        var_combined_results_terms,
        var_combined_results_term
      )
    }
    data.table::fwrite(
      var_combined_results_terms,
      file.path(output_dir, paste0(var, "_combined.csv"))
    )
    results[[var]] <- var_combined_results_terms
  }
  return(results)
}